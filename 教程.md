# 1. 介绍

`OpenRewrite`是一个开源的源代码自动重构工具，使开发人员能够有效地消除代码仓库中的技术债。`OpenRewrite`社区最初支持`Java`语言，同时正在不断扩大语言和框架的覆盖范围。

它由一个自动重构引擎组成，该引擎运行预先打包的、开源的重构规则`recipe`，用于公共框架迁移、安全修复和代码风格一致性迁移，大大减少重构时间。在基于`Maven`的工程中，使用[`OpenRewrite Maven`](https://github.com/openrewrite/rewrite-maven-plugin)插件，可以帮助我们运行这些`recipe`。

`OpenRewrite`的工作原理是对表示源代码的无损语义树（`Lossless Semantic Trees`，`LST`）进行更改，并将修改后的树重写回源代码。对`LST`的修改在`visitor`中执行，而`visitor`被聚合到`recipe`中。由于`LST`的特性，代码原始格式不会被重构过程破坏，实现了最小可控的修改。





# 2. 快速上手

为了体验`OpenRewrite`的功能，让我们以一个实际的代码仓库重构例子说起。

## 步骤1：下载仓库

首先下载官方提供的[`demo`](https://github.com/openrewrite/spring-petclinic-migration)仓库，用`Idea`打开并选择以`Maven`工程读取，设置`JDK`版本为11。

如果是以`Gradle`工程打开，使用自带的`gradle-wrapper.properties`设置可能由于网速原因无法下载`gradle`，调整如下设置

```
distributionUrl=https\://mirrors.cloud.tencent.com/gradle/gradle-6.5.1-bin.zip
```



## 步骤2：添加rewrite-maven-plugin插件

在`pom.xml`文件中添加如下插件配置。

```xml
<plugin>
  <groupId>org.openrewrite.maven</groupId>
  <artifactId>rewrite-maven-plugin</artifactId>
  <version>6.16.0</version>
</plugin>
```

然后在命令行中运行指令`mvn rewrite:discover`，就可以看到`rewrite-maven-plugin`插件本身支持的一些重构`recipe`。

```cmd
$>mvn rewrite:discover
[INFO] Scanning for projects...
[INFO] 
[INFO] ------------< org.springframework.samples:spring-petclinic >------------
[INFO] Building petclinic 1.5.1
[INFO] --------------------------------[ jar ]---------------------------------
[INFO] 
[INFO] --- rewrite-maven-plugin:6.16.0:discover (default-cli) @ spring-petclinic ---
[INFO] Available Recipes:
[INFO]     org.openrewrite.DeleteSourceFiles
[INFO]     org.openrewrite.ExcludeFileFromGitignore
[INFO]     org.openrewrite.FindCollidingSourceFiles
[INFO]     org.openrewrite.FindDeserializationErrors
[INFO]     org.openrewrite.FindSourceFiles
[INFO]     org.openrewrite.groovy.format.AutoFormat
[INFO]     org.openrewrite.java.OrderImports
...
[INFO]     org.openrewrite.yaml.search.FindKey
[INFO]     org.openrewrite.yaml.search.FindProperty
[INFO]     org.openrewrite.yaml.UnfoldProperties
[INFO]
[INFO] Available Styles:
[INFO]     com.netflix.eureka.Style
[INFO]     com.netflix.genie.Style
[INFO]     org.openrewrite.java.GoogleJavaFormat
[INFO]     org.openrewrite.java.IntelliJ
[INFO]     org.openrewrite.java.SpringFormat
[INFO]     org.openrewrite.kotlin.IntelliJ
[INFO]
[INFO] Active Styles:
[INFO]
[INFO] Active Recipes:
[INFO]
[INFO] Found 277 available recipes and 6 available styles.
[INFO] Configured with 1 active recipes and 0 active styles.
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time:  9.979 s
[INFO] Finished at: 2025-08-23T13:40:44+08:00
[INFO] ------------------------------------------------------------------------
```



## 步骤3：激活简单recipe

以`org.openrewrite.java.OrderImports`为例，它是一个可以将`import`的类进行排序的重构`recipe`。要激活它，修改`pom.xml`如下：

```xml
<plugin>
  <groupId>org.openrewrite.maven</groupId>
  <artifactId>rewrite-maven-plugin</artifactId>
  <version>6.16.0</version>
  <configuration>
    <activeRecipes>
      <recipe>org.openrewrite.java.OrderImports</recipe>
    </activeRecipes>
  </configuration>
</plugin>
```

## 步骤4：执行重构

在命令行执行`mvn rewrite:run`。执行完成后，可以使用`Idea`自带的`git diff`功能查看改动是否正确。



## 步骤5：执行复杂recipe重构

`org.openrewrite.java.OrderImports`是一个比较简单的重构`recipe`，不需要设置参数。而对于一些操作更加复杂的重构任务，需要传入参数时，可以通过`rewrite.yml`文件来配置。

比如`org.openrewrite.java.ChangePackage`的作用是重命名文件夹，需要人为指定旧文件夹名以及新文件夹名。它需要的参数如下表所示：

| Type      | Name             | Description                                                  |
| --------- | ---------------- | ------------------------------------------------------------ |
| `String`  | `oldPackageName` | The package name to replace.                                 |
| `String`  | `newPackageName` | New package name to replace the old package name with.       |
| `Boolean` | `recursive`      | *Optional*. Whether or not to recursively change subpackage names. |

假如我们需要将包`org.springframework.samples.petclinic.vet`重命名为`org.springframework.samples.petclinic.veterinary`，首先在项目根目录下的`rewrite.yml`文件添加如下配置：

```yml
---
type: specs.openrewrite.org/v1beta/recipe
name: com.yourorg.VetToVeterinary
recipeList:
  - org.openrewrite.java.ChangePackage:
      oldPackageName: org.springframework.samples.petclinic.vet
      newPackageName: org.springframework.samples.petclinic.veterinary
```

这样我们就得到了一个名字叫做`com.yourorg.VetToVeterinary`的`recipe`，它内部包含了`org.openrewrite.java.ChangePackage`这个`sub-recipe`，并且设置了新、旧包名。

接着我们在`pom.xml`文件中激活这个`recipe`。此时执行`mvn rewrite:discover`可以看到已经识别到了`com.yourorg.VetToVeterinary`。

```xml
<build>
  <plugins>
    <plugin>
      <groupId>org.openrewrite.maven</groupId>
      <artifactId>rewrite-maven-plugin</artifactId>
      <version>6.16.0</version>
      <configuration>
        <activeRecipes>
          <recipe>org.openrewrite.java.OrderImports</recipe>
          <recipe>com.yourorg.VetToVeterinary</recipe>
        </activeRecipes>
      </configuration>
    </plugin>
  </plugins>
</build>
```

现在执行`mvn rewrite:run`可以看到包名被正确的替换了。



## 步骤6：执行外部模块中的recipe重构

`rewrite-maven-plugin`中支持的`recipe`仅仅只有270多个，而在开源社区中，还有很多其他开发者编写好的`recipe`，我们可以在`pom.xml`中引入这些模块，从而扩展重构能力。

比如说我们想使用`org.openrewrite.recipe:rewrite-spring:version`包中提供的`org.openrewrite.java.spring.boot2.SpringBoot2JUnit4to5Migration`，实现从`JUnit`4到5的重构，可以在`pom.xml`中如下配置：

```xml
<build>
  <plugins>
      <plugin>
        <groupId>org.openrewrite.maven</groupId>
        <artifactId>rewrite-maven-plugin</artifactId>
        <version>6.16.0</version>
        <configuration>
          <activeRecipes>
            <recipe>org.openrewrite.java.OrderImports</recipe>
            <recipe>com.yourorg.VetToVeterinary</recipe>
            <recipe>org.openrewrite.java.spring.boot2.SpringBoot2JUnit4to5Migration</recipe>
          </activeRecipes>
        </configuration>
        <dependencies>
          <dependency>
            <groupId>org.openrewrite.recipe</groupId>
            <artifactId>rewrite-spring</artifactId>
            <version>{{VERSION_REWRITE_SPRING}}</version>
          </dependency>
        </dependencies>
      </plugin>
  </plugins>
<build>
```



# 3. 常用的recipe

https://docs.openrewrite.org/popular-recipe-guides





# 4. 编写自己的recipe

## 4.1 项目环境设置

要求`JDK 21`，`Maven 3.2+`。

### 方案1：手动构造项目

使用`mvn`工具生成一个模板项目。

```cmd
mvn -B archetype:generate -DgroupId=com.mycompany.app -DartifactId=my-app -DarchetypeArtifactId=maven-archetype-quickstart -DarchetypeVersion=1.5
```

命令参数解释如下。

| 参数                    | 说明                         | 示例值                       | 作用                                              |
| ----------------------- | ---------------------------- | ---------------------------- | ------------------------------------------------- |
| `-B`                    | 批处理模式 (Batch mode)      | `-B`                         | 不交互式执行，避免在命令行提示输入，常用于脚本/CI |
| `archetype:generate`    | Maven Archetype 插件的目标   | `archetype:generate`         | 生成一个新项目的骨架 (模板)                       |
| `-DgroupId`             | 项目的 **Group ID**          | `com.mycompany.app`          | 类似 Java 包名，用于区分组织或公司                |
| `-DartifactId`          | 项目的 **Artifact ID**       | `my-app`                     | 项目名称，也是生成的目录名                        |
| `-DarchetypeArtifactId` | 使用的 **Archetype 模板 ID** | `maven-archetype-quickstart` | 指定用哪个模板生成项目                            |
| `-DarchetypeVersion`    | 模板的版本                   | `1.5`                        | 选择模板的具体版本，确保可复现                    |



`Rewrite`提供了一个物料清单（`Bill of Materials`，`BOM`），当导入到构建中时，它将管理项目中包含的任何`Rewrite`依赖项的版本。我们将`rewrite-recipe-bom`导入`Maven`，然后在不指定版本的情况下使用外部模块。

我们希望做`Java recipe`开发，所以引入`rewrite-java`，同时根据使用的版本，引入`rewrite-java-21`依赖。

这里还推荐加入`lombok`以及`rewrite-test`依赖。

```xml
<dependencyManagement>
  <dependencies>
      <!-- 设置了依赖包版本 -->
      <dependency>
          <groupId>org.openrewrite.recipe</groupId>
          <artifactId>rewrite-recipe-bom</artifactId>
          <version>3.13.0</version>
          <type>pom</type>
          <scope>import</scope>
      </dependency>
      <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
        <version>1.18.36</version>
      </dependency>
  </dependencies>
</dependencyManagement>

<dependencies>
	<!-- Java Recipe 开发依赖于 rewrite-java -->
    <dependency>
        <groupId>org.openrewrite</groupId>
        <artifactId>rewrite-java</artifactId>
        <scope>compile</scope>
    </dependency>
    
    <!-- 根据当前Java版本设置 -->
    <dependency>
        <groupId>org.openrewrite</groupId>
        <artifactId>rewrite-java-21</artifactId>
        <scope>runtime</scope>
    </dependency>
    
    <!-- lombok is optional, but recommended for authoring recipes -->
    <dependency>
      <groupId>org.projectlombok</groupId>
      <artifactId>lombok</artifactId>
      <optional>true</optional>
    </dependency>
    
    <!-- For authoring tests for any kind of Recipe -->
    <dependency>
        <groupId>org.openrewrite</groupId>
        <artifactId>rewrite-test</artifactId>
        <scope>test</scope>
    </dependency>
</dependencies>


<build>
    <plugins>
        <plugin>
            <artifactId>maven-surefire-plugin</artifactId>
        </plugin>
        <plugin>
            <groupId>org.apache.maven.plugins</groupId>
            <artifactId>maven-compiler-plugin</artifactId>
            <version>3.13.0</version>
            <configuration>
                <!-- lombok is optional, but recommended for authoring recipes -->
                <annotationProcessorPaths>
                    <path>
                        <groupId>org.projectlombok</groupId>
                        <artifactId>lombok</artifactId>
                    </path>
                </annotationProcessorPaths>
            </configuration>
        </plugin>
    </plugins>
</build>
```



一些`recipe`实现可以通过定义注释（如`@JsonCreator`和`@JsonProperty`）来使用`Jackson`反序列化。

为了反序列化`Java`类，需要添加`-parameters`编译器参数。这对于`Jackson`能够反序列化类的构造函数参数是必要的。

```xml
<build>
    <plugins>
        <plugin>
            <groupId>org.apache.maven.plugins</groupId>
            <artifactId>maven-compiler-plugin</artifactId>
            <version>3.14.0</version>
            <configuration>
                <compilerArgs>
                    <arg>-parameters</arg>
                </compilerArgs>
            </configuration>
        </plugin>
    </plugins>
</build>
```



到现在，我们的项目就创建完成了，可以继续后续`recipe`开发。



### 方案2：从模板构造项目

使用[`rewrite-recipe-starter`](https://github.com/moderneinc/rewrite-recipe-starter)仓库，点击“使用此模板”按钮。该模板已经设置了所有必要的依赖项、构建配置、示例`recipe`。





## 4.2 recipe类型

在开始编写`recipe`之前，重要的是要弄清楚要制作什么类型的`recipe`。

`OpenRewrite`提供了对三种不同类型的`recipe`的支持：`declarative`、`refaster`和`imperative`。每一种方法都有自己的优点和缺点，这取决于想要构建的配方类型。



### Declarative（声明式）

它是最简单和最常见的`recipe`，完全是用YAML编写的，它们通常将现有的`recipe`捆绑在一起，同时向它们添加一些轻量级配置。

公共静态分析`recipe`就是一个很好的例子。它采用了一堆与静态分析相关的简单`recipe`，并将它们组合成一个更容易运行的大配方。它不添加任何逻辑，也不改变现有的`recipe`。

```yml
---
type: specs.openrewrite.org/v1beta/recipe
name: org.openrewrite.staticanalysis.CommonStaticAnalysis
displayName: Common static analysis issues
description: Resolve common static analysis issues discovered through 3rd party tools.
recipeList:
  - org.openrewrite.staticanalysis.AtomicPrimitiveEqualsUsesGet
  - org.openrewrite.staticanalysis.BigDecimalRoundingConstantsToEnums
  - org.openrewrite.staticanalysis.BooleanChecksNotInverted
  - org.openrewrite.staticanalysis.CaseInsensitiveComparisonsDoNotChangeCase
  - org.openrewrite.staticanalysis.CatchClauseOnlyRethrows
  - org.openrewrite.staticanalysis.ChainStringBuilderAppendCalls
  # ...
---
```

作为最佳实践，如果`recipe`可以是声明性的（这意味着它可以基于其他`recipe`构建），那么应该使它具有声明性。





### Refaster（模板式）

`Refaster`只能用于用一个表达式替换另一个表达式，或者用另一个语句替换一个表达式。因此，它们==**非常适合直接替换**==，例如将`StringUtils.equals`转换为`Objects.equals`。不过，不仅仅是字符串的替换，还提供编译器和类型支持。

想要创建`Refaster`模板，参考https://errorprone.info/docs/refaster

`Refaster`模板`recipe`也可以作为更复杂`recipe`实现的起点。这是因为，当定义`Refaster`模板时，在幕后实际创建的是`imperative`命令式`recipe`。在构建存储库之后，可以在构建目录中找到这些命令式`recipe`。



### Imperative（命令式）

命令式`recipe`提供了最大的自由和功能，但代价是更难以创建。它们允许编写`Java`代码来实现`recipe`。

命令式`recipe`非常适合需要确定应该更改什么或应该更改成什么内容的复杂性或细微差别的情况。例如，如果想将`final`修饰符添加到任何未重新赋值的局部变量中，则需要创建一个命令式`recipe`，因为`refaster`模板无法确定变量是否已被重新赋值。

下面是一个实现例子：https://github.com/openrewrite/rewrite-static-analysis/blob/main/src/main/java/org/openrewrite/staticanalysis/FinalizeLocalVariables.java





## 4.3 写一个imperative命令式recipe

了解了`recipe`的类型，看起来命令式还是最高级，所以我们来尝试写一个配方，向某个类中添加一个`hello`方法。（声明式也很简单，推荐）



### 步骤1：创建recipe

在4.1节创建好的项目中添加一个`SayHelloRecipe`类：

```java
package com.mycompany.app;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.NonNull;
import org.openrewrite.*;

// 使 recipe 不可变有助于使它们幂等，并消除各种可能的错误。
// 所有 recipe 必须是可序列化的。这可以通过测试中的RewriteTest.rewriteRun()进行验证。
@Value
@EqualsAndHashCode(callSuper = false)
public class SayHelloRecipe extends Recipe {
    @Option(displayName = "Fully Qualified Class Name",
            description = "A fully qualified class name indicating which class to add a hello() method to.",
            example = "com.yourorg.FooBar")
    @NonNull
    String fullyQualifiedClassName;

    public SayHelloRecipe() {
        fullyQualifiedClassName = "";
    }

    // All recipes must be serializable. This is verified by RewriteTest.rewriteRun() in your tests.
    @JsonCreator
    public SayHelloRecipe(@NonNull @JsonProperty("fullyQualifiedClassName") String fullyQualifiedClassName) {
        this.fullyQualifiedClassName = fullyQualifiedClassName;
    }

    @Override
    public String getDisplayName() {
        return "Say Hello";
    }

    @Override
    public String getDescription() {
        return "Adds a \"hello\" method to the specified class.";
    }

    // TODO: Override getVisitor() to return a JavaIsoVisitor to perform the refactoring
}
```

其中使用到的注解和说明：

| 注解                                               | 说明                                                         |
| -------------------------------------------------- | ------------------------------------------------------------ |
| `lombok.Value`                                     | 来自 **Lombok**，是一个组合注解，作用是把类变成 **不可变类 (immutable class)**。<br />具体效果：<br />**类自动加上 `final`**（不能被继承）<br />**所有字段默认是 `private final`**（不可变，只能通过构造函数赋值）<br />**自动生成全参构造函数**（包含所有字段）<br />**自动生成 getter 方法**（但没有 setter）<br />自动生成 `toString()`、`equals()`、`hashCode()` 方法 |
| `lombok.@EqualsAndHashCode(callSuper = false)`     | 同样来自 **Lombok**，用于控制 **equals() 和 hashCode() 的生成策略**。<br />默认情况下，Lombok 会根据所有字段生成 `equals()` 和 `hashCode()`。 如果类有继承关系，你可以选择是否包含父类的字段。<br />这里 `callSuper = false` 表示：<br />**不调用父类 (`Recipe`) 的 `equals()` 和 `hashCode()`** <br />只根据当前类 `SayHelloRecipe` 的字段来生成。<br />这样可以避免父类的状态影响比较逻辑（通常 Recipe 父类是抽象基类，没必要参与）。 |
| `jackson.@JsonCreator`                             | 作用：告诉 **Jackson**（JSON 序列化/反序列化库）在反序列化时应该使用这个构造函数来创建对象。<br />没有它的话，Jackson 默认会用 **无参构造函数 + setter**。<br />有了它，即使类是不可变的（只有 `final` 字段，没有 setter），Jackson 也能正确通过这个构造函数实例化对象。 |
| `jackson.@JsonProperty("fullyQualifiedClassName")` | 作用：告诉 Jackson **JSON 字段和构造函数参数的映射关系**。<br />这里表示：当 JSON 数据里有字段 `"fullyQualifiedClassName"` 时，把它的值传给构造函数参数 `fullyQualifiedClassName`。<br />没有它的话，Jackson 只能靠参数名（编译后可能丢失）猜测映射，容易出错。 |



### 步骤2：编写测试代码

我们编写的这个`recipe`要求实现的功能：

- 与特定类名匹配的，如果没有`hello`方法，则创建一个
- 与特定类名匹配的，如果已经有`hello`方法，则不做处理
- 不匹配特定类名，不做处理

按照测试驱动开发的思想，可以创建下面的测试类

```java
package com.mycompany.app;

import org.junit.jupiter.api.Test;
import org.openrewrite.test.RecipeSpec;
import org.openrewrite.test.RewriteTest;

import static org.openrewrite.java.Assertions.java;

class SayHelloRecipeTest implements RewriteTest {
    @Override
    public void defaults(RecipeSpec spec) {
        spec.recipe(new SayHelloRecipe("com.yourorg.FooBar"));
    }

    @Test
    void addsHelloToFooBar() {
        rewriteRun(
                java(
                        """
                            package com.yourorg;
        
                            class FooBar {
                            }
                        """,
                        """
                            package com.yourorg;
        
                            class FooBar {
                                public String hello() {
                                    return "Hello from com.yourorg.FooBar!";
                                }
                            }
                        """
                )
        );
    }

    @Test
    void doesNotChangeExistingHello() {
        rewriteRun(
                java(
                        """
                            package com.yourorg;
                
                            class FooBar {
                                public String hello() { return ""; }
                            }
                        """
                )
        );
    }

    @Test
    void doesNotChangeOtherClasses() {
        rewriteRun(
                java(
                        """
                            package com.yourorg;
                
                            class Bash {
                            }
                        """
                )
        );
    }
}
```

测试文件实现了`RewriteTest`接口，该接口通过`rewriteRun`的方法变体为测试基础结构提供了一个入口点。

可以通过`defaults()`方法为所有测试设置默认值，这样就不必在每个测试中重复相同的代码。

在每个测试中，我们会定义源代码的`before`和`after`状态，表示经过`recipe`重构之后的变化。如果期望发生变化，则会自动比较`after`的值。如果期望没有发生源代码修改，`after`字段可以留空不填写。



### 步骤3：编写visitor

`visitor`会检查无损语义树`LST`，对满足条件的代码进行修改。因此我们需要首先判断如何通过`LST`找到特定的类。下面是原文给出的答案，感兴趣可以进行阅读。

> If we take a look at the [LST Examples doc](https://docs.openrewrite.org/concepts-and-explanations/lst-examples), we can see that a [J.ClassDeclaration](https://github.com/openrewrite/rewrite/blob/v7.34.0/rewrite-java/src/main/java/org/openrewrite/java/tree/J.java#L1062-L1336) has the information we need. It has a `FullyQualified` type that we can use to ensure we're only making changes on the specified class, and it contains a `Block` that includes `Statements` that may be `MethodDeclarations`, so we can check for a `hello()` method and potentially add one if it doesn't exist.

找到需要修改的类之后，我们根据模板来插入`hello()`方法。原文如下

> In order to create complex LST elements such as a new method, it's a good idea to use a [Java Template](https://docs.openrewrite.org/concepts-and-explanations/javatemplate). At a high-level, Java Templates simplify the creation of LSTs by converting code snippets into fully created LSTs.
>
> Templates are created using the `JavaTemplate.builder()` method. Within a template, `#{}` can be used to signify that a value will be substituted there later on. In our recipe, for instance, we don't know what the fully qualified class name is when we're compiling the program. Instead, we need to rely on the user to provide that later.

最终的代码如下，此时运行测试会得到正确的结果。

```java
package com.mycompany.app;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.NonNull;
import org.openrewrite.*;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.JavaTemplate;
import org.openrewrite.java.tree.J;

// 使 recipe 不可变有助于使它们幂等，并消除各种可能的错误。
// 所有 recipe 必须是可序列化的。这可以通过测试中的RewriteTest.rewriteRun()进行验证。
@Value
@EqualsAndHashCode(callSuper = false)
public class SayHelloRecipe extends Recipe {
    @Option(displayName = "Fully Qualified Class Name",
            description = "A fully qualified class name indicating which class to add a hello() method to.",
            example = "com.yourorg.FooBar")
    @NonNull
    String fullyQualifiedClassName;

    public SayHelloRecipe() {
        fullyQualifiedClassName = "";
    }

    // All recipes must be serializable. This is verified by RewriteTest.rewriteRun() in your tests.
    @JsonCreator
    public SayHelloRecipe(@NonNull @JsonProperty("fullyQualifiedClassName") String fullyQualifiedClassName) {
        this.fullyQualifiedClassName = fullyQualifiedClassName;
    }

    @Override
    public String getDisplayName() {
        return "Say Hello";
    }

    @Override
    public String getDescription() {
        return "Adds a \"hello\" method to the specified class.";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        // getVisitor() should always return a new instance of the visitor to avoid any state leaking between cycles
        return new SayHelloVisitor();
    }

    public class SayHelloVisitor extends JavaIsoVisitor<ExecutionContext> {
        private final JavaTemplate helloTemplate =
                JavaTemplate.builder( "public String hello() { return \"Hello from #{}!\"; }")
                        .build();

        @Override
        public J.ClassDeclaration visitClassDeclaration(J.ClassDeclaration classDecl, ExecutionContext executionContext) {
            // TODO: Filter out classes that don't match the fully qualified name
            if (classDecl.getType() == null || !classDecl.getType().getFullyQualifiedName().equals(fullyQualifiedClassName)) {
                return classDecl;
            }

            // TODO: Filter out classes that already have a `hello()` method
            boolean helloMethodExists = classDecl.getBody().getStatements().stream()
                    .filter(statement -> statement instanceof J.MethodDeclaration)
                    .map(J.MethodDeclaration.class::cast)
                    .anyMatch(methodDeclaration -> methodDeclaration.getName().getSimpleName().equals("hello"));

            // If the class already has a `hello()` method, don't make any changes to it.
            if (helloMethodExists) {
                return classDecl;
            }

            // TODO: Add a `hello()` method to classes that need it
            classDecl = classDecl.withBody( helloTemplate.apply(new Cursor(getCursor(), classDecl.getBody()),
                    classDecl.getBody().getCoordinates().lastStatement(),
                    fullyQualifiedClassName ));

            return classDecl;
        }
    }
}
```







## 4.4 发布jar包并使用

运行命令将`jar`包发布到本地仓库`~/.m2/repository`，这样在别的项目里就可以通过依赖坐标`groupId:artifactId:version`来使用它。比如`~/.m2/repository/com/mycompany/app/my-app/1.0-SNAPSHOT/my-app-1.0-SNAPSHOT.jar`。

对于windows来说，发布在`C:\Users\user name\.m2\repository\com\mycompany\app\my-app\1.0-SNAPSHOT\my-app-1.0-SNAPSHOT.jar`

```cmd
mvn install
```

于是我们可以在之前下载好的[`demo`](https://github.com/openrewrite/spring-petclinic-migration)上进行本地测试。在`pom.xml`文件中激活`recipe`

```xml
<plugin>
    <groupId>org.openrewrite.maven</groupId>
    <artifactId>rewrite-maven-plugin</artifactId>
    <version>6.16.0</version>
    <configuration>
        <activeRecipes>
            <!-- 注意recipe名字不要写错 -->
            <recipe>com.myorg.AddHelloMethod</recipe>
        </activeRecipes>
    </configuration>
    <dependencies>
        <dependency>
            <groupId>com.mycompany.app</groupId>
            <artifactId>my-app</artifactId>
            <version>1.0-SNAPSHOT</version>
        </dependency>
    </dependencies>
</plugin>
```

然后在`rewrite.yml`文件中配置入参

```yml
---
type: specs.openrewrite.org/v1beta/recipe
name: com.myorg.AddHelloMethod
recipeList:
  - com.mycompany.app.SayHelloRecipe:
      fullyQualifiedClassName: org.springframework.samples.petclinic.PetClinicApplication
```

顺利的话，直接运行`mvn rewrite:run`就能看到正确结果了。

测试通过后，将这个`jar`包发布到中央仓库（或者企业仓库）。https://maven.apache.org/repository/guide-central-repository-upload.html

`rewrite-recipe-starter`项目被配置为发布到`Moderne`的开放工件存储库（通过`build.gradle.kts`文件底部的发布任务）。如果要在其他地方发布，则需要更新该任务。





## 4.5 深入了解rewrite-test

当开发新的`recipe`时，测试它们是非常重要的，以确保它们不仅做了预期的更改，而且也没有做不必要的更改。

为了对`recipe`进行测试，你需要在工程中引入依赖：

```xml
<project>
    <dependencyManagement>
      <dependencies>
          <dependency>
              <groupId>org.openrewrite.recipe</groupId>
              <artifactId>rewrite-recipe-bom</artifactId>
              <version>3.13.0</version>
              <type>pom</type>
              <scope>import</scope>
          </dependency>
      </dependencies>
    </dependencyManagement>
    ...
    <dependencies>
        <!-- The RewriteTest class needed for testing recipes -->
        <dependency>
            <groupId>org.openrewrite</groupId>
            <artifactId>rewrite-test</artifactId>
            <scope>test</scope>
        </dependency>
        
         <!-- Java Recipe 开发依赖于 rewrite-java -->
        <dependency>
              <groupId>org.openrewrite</groupId>
              <artifactId>rewrite-java</artifactId>
              <scope>compile</scope>
        </dependency>

        <!-- 根据当前Java版本设置 -->
        <dependency>
              <groupId>org.openrewrite</groupId>
              <artifactId>rewrite-java-17</artifactId>
              <scope>runtime</scope>
        </dependency>
    </dependencies>
</project>    
```

现在可以编写测试类了，一个测试类需要：

- 实现`RewriteTest `接口
- 在`defaults()`方法中确定需要测试的`recipe`
- 定义源文件断言`rewriteRun`



### 命令式recipe测试

下面是一个例子。

```java
package com.yourorg;

import org.junit.jupiter.api.Test;
import org.openrewrite.PathUtils;
import org.openrewrite.java.JavaParser;
import org.openrewrite.test.RecipeSpec;
import org.openrewrite.test.RewriteTest;

import java.nio.file.Paths;

import static org.openrewrite.java.Assertions.java;
import static org.assertj.core.api.Assertions.assertThat;

class LowercasePackageTest implements RewriteTest {

    // Note, you can define defaults for the RecipeSpec and these defaults will be
    // used for all tests.
    @Override
    public void defaults(RecipeSpec spec) {
        spec.recipe(new LowercasePackage());
    }

    // A Java source file that already has a lowercase package name should be left
    // unchanged.
    @Test
    void packageIsAlreadyLowercase() {
        rewriteRun(
            java(
                """
                    package com.yourorg;

                    class A {}
                """
            )
        );
    }

    // Assert that a Java source file with uppercase letters in its package name
    // is correctly transformed by the recipe.
    @Test
    void lowerCasePackage() {
        // Each test can customize the RecipeSpec before the test is executed.
        // In this case, the recipe has already been defined in defaults(). We
        // can extend that and add a parser that logs warnings and errors for
        // just this test.
        rewriteRun(
            // You'll need to have an SLF4J logger configured to see
            // these warnings and errors.
            spec -> spec
                    .parser(JavaParser.fromJavaVersion()
                            .logCompilationWarningsAndErrors(true)),
            java(
                // The Java source file before the recipe is run:
                """
                    package com.UPPERCASE.CamelCase;
                    class FooBar {}
                """,
                // The expected Java source file after the recipe is run:
                """
                    package com.uppercase.camelcase;
                    class FooBar {}
                """,
                // An optional callback that can be used after the recipe has been
                // executed to assert additional conditions on the resulting source file:
                spec -> spec.afterRecipe(cu -> assertThat(PathUtils.equalIgnoringSeparators(cu.getSourcePath(), Paths.get("com/uppercase/camelcase/FooBar.java"))).isTrue()))
        );
    }

    // Demonstrates how you can do multiple checks in one test.
    //
    // You can also combine different types (such as `java` and `text`) in one test:
    // https://github.com/openrewrite/rewrite-spring/blob/main/src/testWithSpringBoot_2_7/java/org/openrewrite/java/spring/boot2/MoveAutoConfigurationToImportsFileTest.java#L177-L224
    @Test
    void combinedExample() {
        rewriteRun(
            // Assert the first source file is not modified.
            java(
                """
                    package com.lowercase;
                    class A {}
                """
            ),
            // Assert the second source file is modified.
            java(
                """
                    package com.UPPERCASE.CamelCase;
                    class FooBar {}
                """,
                """
                    package com.uppercase.camelcase;
                    class FooBar {}
                """
            )
        );
    }
}
```



### 声明式recipe测试

声明式`recipe`在很大程度上与命令式`recipe`相似的方式进行测试。测试中的一个关键区别是，需要使用`recipeFromResources`方法将规范指向资源目录，也就是说，必须确保该`rewrite.yml`位于`src/main/resources/META-INF/rewrite`目录中。

以下面这个`rewrite.yml`为例：

```yml
---
type: specs.openrewrite.org/v1beta/recipe
name: com.yourorg.UseApacheStringUtils
displayName: Use Apache `StringUtils`
description: Replace Spring string utilities with Apache string utilities.
recipeList:
  - org.openrewrite.java.dependencies.AddDependency:
      groupId: org.apache.commons
      artifactId: commons-lang3
      version: latest.release
      onlyIfUsing: org.springframework.util.StringUtils
      configuration: implementation
  - org.openrewrite.java.ChangeType:
      oldFullyQualifiedTypeName: org.springframework.util.StringUtils
      newFullyQualifiedTypeName: org.apache.commons.lang3.StringUtils
```

编写测试文件如下：

```java
package com.mycompany.app;


import org.junit.jupiter.api.Test;
import org.openrewrite.DocumentExample;
import org.openrewrite.java.JavaParser;
import org.openrewrite.test.RecipeSpec;
import org.openrewrite.test.RewriteTest;

import static org.openrewrite.java.Assertions.java;

public class UseApacheStringUtilsTest implements RewriteTest {
    @Override
    public void defaults(RecipeSpec spec) {
        spec.recipeFromResources("com.yourorg.UseApacheStringUtils")
                // Notice how we only pass in `spring-core` as the classpath, but not `commons-lang3`.
                // That's because we only need dependencies to compile the before code blocks, not the after code blocks.
                .parser(JavaParser.fromJavaVersion().classpath("spring-core"));
    }

    @DocumentExample
    @Test
    public void replacesStringEquals() {
        rewriteRun(
                //language=java
                java(
                        """
                          import org.springframework.util.StringUtils;
        
                          class A {
                              boolean test(String s) {
                                  return StringUtils.containsWhitespace(s);
                              }
                          }
                          """,
                        """
                          import org.apache.commons.lang3.StringUtils;
        
                          class A {
                              boolean test(String s) {
                                  return StringUtils.containsWhitespace(s);
                              }
                          }
                          """
                )
        );
    }


    @Test
    public void noChangeWhenAlreadyUsingCommonsLang3() {
        rewriteRun(
                // By passing in `commons-lang3` as the classpath here, we ensure that the before code block compiles.
                spec -> spec.parser(JavaParser.fromJavaVersion().classpath("commons-lang3")),
                //language=java
                java(
                        """
                          import org.apache.commons.lang3.StringUtils;
        
                          class A {
                              boolean test(String s) {
                                  return StringUtils.containsWhitespace(s);
                              }
                          }
                          """
                        // The absence of a second argument to `java` indicates that the after code block should be the same as the before code block.
                )
        );
    }
}

```



### 高级测试

请参考官方文档。





## 4.6 编写recipe的几个准则（最佳实践）

- 一个`recipe`应该只关注一个功能
- 重构之后不能破坏原有代码的正确性
- 尽量使用声明式`recipe`

[Recipe conventions and best practices | OpenRewrite Docs](https://docs.openrewrite.org/authoring-recipes/recipe-conventions-and-best-practices)



## 4.7 使用JavaTemplates修改已有方法

在4.3中我们使用`JavaTemplates`实现了向某个类添加`hello`方法，但我们还可以实现更复杂、更细粒度的修改。

在下面这个例子中，我们将：

- 删除方法的`abstract`修饰符
- 给方法增加参数
- 在方法中增加语句

先把测试写好，方便我们理解

```java
package org.springframework.samples.petclinic.recipe;

import org.junit.jupiter.api.Test;
import org.openrewrite.test.RecipeSpec;
import org.openrewrite.test.RewriteTest;

import static org.junit.jupiter.api.Assertions.*;
import static org.openrewrite.java.Assertions.java;

class ExpandCustomerInfoTest implements RewriteTest {
    @Override
    public void defaults(RecipeSpec spec) {
        spec.recipe(new ExpandCustomerInfo());
    }

    @Test
    public void doesNotModifyUnexpectedMethods() {
        rewriteRun(
            java(
                """
                    package com.yourorg;

                    import java.util.Date;

                    public abstract class Customer {
                        private Date dateOfBirth;
                        private String firstName;
                        private String lastName;

                        public abstract void setOtherCustomerInfo(String lastName);

                        public void setCustomerInfo(int meow) {
                            System.out.println("Hello " + meow);
                        }
                    }
                """
            )
        );
    }

    @Test
    public void expandsExpectedCustomerInfoMethod() {
        rewriteRun(
            java(
                """
                    package com.yourorg;

                    import java.util.Date;

                    public abstract class Customer {
                        private Date dateOfBirth;
                        private String firstName;
                        private String lastName;

                        public abstract void setCustomerInfo(String lastName);
                    }
                """,
                """
                    package com.yourorg;

                    import java.util.Date;

                    public abstract class Customer {
                        private Date dateOfBirth;
                        private String firstName;
                        private String lastName;

                        public void setCustomerInfo(Date dateOfBirth, String firstName, String lastName) {
                            this.dateOfBirth = dateOfBirth;
                            this.firstName = firstName;
                            this.lastName = lastName;
                        }
                    }
                """
            )
        );
    }
}

```



好的，接下里我们需要做以下操作：

- 找到符合要求的抽象方法。推荐使用[`MethodMatcher`](https://github.com/openrewrite/rewrite/blob/main/rewrite-java/src/main/java/org/openrewrite/java/MethodMatcher.java)
- 删除方法的抽象修饰符
- 为方法添加参数。避免手工构造LST元素，我们应该使用`JavaTemplate`类来构造需要的任何对象。
- 为方法增加方法体。同样使用`JavaTemplate`实现，需要注意的是抽象方法一开始没有方法体，所以需要先设置。
- 为方法体增加语句。请注意语句是位置敏感的，因此需要使用`contextSensitive`



每一步的操作都在下面展示了

```java
package org.springframework.samples.petclinic.recipe;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Recipe;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.JavaTemplate;
import org.openrewrite.java.MethodMatcher;
import org.openrewrite.java.tree.J;

import java.util.stream.Collectors;

public class ExpandCustomerInfo extends Recipe {
    @Override
    public String getDisplayName() {
        return "This is ExpandCustomerInfo";
    }

    @Override
    public String getDescription() {
        return "Expand the `CustomerInfo` class with new fields.";
    }

    @Override
    public JavaIsoVisitor<ExecutionContext> getVisitor() {
        return new JavaIsoVisitor<ExecutionContext>() {
            // Used to identify the method declaration that will be refactored
            private final MethodMatcher methodMatcher = new MethodMatcher("com.yourorg.Customer setCustomerInfo(String)");

            // Template used to insert two additional parameters into the "setCustomerInfo()" method declaration
            private final JavaTemplate addMethodParametersTemplate = JavaTemplate.builder("Date dateOfBirth, String firstName, #{}")
                .imports("java.util.Date")
                .build();

            // Template used to add a method body to the "setCustomerInfo()" method declaration
            private final JavaTemplate addMethodBodyTemplate = JavaTemplate.builder(" ").build();

            // Template used to add statements to the method body of the "setCustomerInfo()" method
            private final JavaTemplate addStatementsTemplate = JavaTemplate.builder(
                    "this.dateOfBirth = dateOfBirth;\n" +
                        "this.firstName = firstName;\n" +
                        "this.lastName = lastName;\n")
                .contextSensitive()
                .build();

            @Override
            public J.MethodDeclaration visitMethodDeclaration(J.MethodDeclaration method, ExecutionContext executionContext) {
                if (!methodMatcher.matches(method.getMethodType())) {
                    // 不匹配方法名，直接返回
                    return method;
                }

                // 删除abstract修饰符
                // withModifiers方法重新构造一个MethodDeclaration
                method = method.withModifiers(method.getModifiers().stream().
                    filter(modifier -> modifier.getType() != J.Modifier.Type.Abstract).collect(Collectors.toList()));

                // Add two parameters to the method declaration by inserting them in front of the first argument
                method =
                    addMethodParametersTemplate.apply(updateCursor(method),
                        method.getCoordinates().replaceParameters(),
                        method.getParameters().get(0));

                // Add a method body and format it
                method = maybeAutoFormat(
                    method, addMethodBodyTemplate.apply(updateCursor(method), method.getCoordinates().replaceBody()),
                    executionContext
                );

                // Safe to assert since we just added a body to the method
                assert method.getBody() != null;

                // Add the assignment statements to the "setCustomerInfo()" method body
                method = addStatementsTemplate.apply(updateCursor(method), method.getBody().getCoordinates().lastStatement());

                return method;
            }
        };
    }
}

```





## 4.8 recipe输出data table

一般来说，`recipe`要么试图通过直接更新代码来修复问题，要么根据查询找到代码片段。但是，如果我们想从代码中提取一些特定的属性或推论，该怎么办呢？例如，如果想了解某个代码仓库中存在的漏洞的详细信息，该怎么办？

`recipe`的数据表（`data table`）可以实现上述功能。除了直接修改代码之外，`recipe`还可以生成人们可以用于分析目的的表格数据。以安全漏洞场景为例，`recipe`可以修复某些漏洞，并生成一个表，其中包含关于代码仓库中存在哪些漏洞的重要信息。此信息可能包括CVE的摘要、问题的严重程度以及版本更新是否可以解决该漏洞。

现在让我们着手写一个可以产生`data table`的`recipe`。



### 步骤1：定义数据表

- 继承`DataTable`类
- 创建内部类`Row`定义需要展示的数据

```java
package com.yourorg.table;

import lombok.Value;
import org.openrewrite.Column;
import org.openrewrite.DataTable;
import org.openrewrite.Recipe;

public class ClassHierarchyReport extends DataTable<ClassHierarchyReport.Row> {

    public ClassHierarchyReport(Recipe recipe) {
        super(recipe,
                "Class hierarchy report",
                "Records inheritance relationships between classes.");
    }

    @Value
    public static class Row {
        @Column(displayName = "Class name",
                description = "Fully qualified name of the class.")
        String className;

        @Column(displayName = "Relationship",
                description = "Whether the class implements a super interface or extends a superclass.")
        Relationship relationship;

        @Column(displayName = "Super class name",
                description = "Fully qualified name of the superclass.")
        String superClassName;
    }

    public enum Relationship {
        EXTENDS,
        IMPLEMENTS
    }
}
```



### 步骤2：在`recipe`中插入数据列

由于我们定义的是类层级关系，所以需要在`visitClassDeclaration`方法中处理。调用`insertRow`来插入数据列。

```java
package com.yourorg;

import com.yourorg.table.ClassHierarchyReport;
import lombok.EqualsAndHashCode;
import lombok.Value;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaType;

@Value
@EqualsAndHashCode(callSuper = false)
public class ClassHierarchy extends Recipe {

    transient ClassHierarchyReport report = new ClassHierarchyReport(this);

    @Override
    public String getDisplayName() {
        return "Class hierarchy";
    }

    @Override
    public String getDescription() {
        return "Produces a data table showing inheritance relationships between classes.";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new JavaIsoVisitor<ExecutionContext>() {

            @Override
            public J.ClassDeclaration visitClassDeclaration(J.ClassDeclaration classDecl, ExecutionContext ctx) {
                JavaType.FullyQualified type = classDecl.getType();
                // Capture all classes, which all extend java.lang.Object
                if (type instanceof JavaType.Class && type.getSupertype() != null) {
                    JavaType.FullyQualified supertype = type.getSupertype();
                    // Capture the direct superclass
                    report.insertRow(ctx, new ClassHierarchyReport.Row(
                            type.getFullyQualifiedName(),
                            ClassHierarchyReport.Relationship.EXTENDS,
                            supertype.getFullyQualifiedName()));

                    // Capture all interfaces
                    for (JavaType.FullyQualified anInterface : type.getInterfaces()) {
                        report.insertRow(ctx, new ClassHierarchyReport.Row(
                                type.getFullyQualifiedName(),
                                ClassHierarchyReport.Relationship.IMPLEMENTS,
                                anInterface.getFullyQualifiedName()
                        ));
                    }
                }
                return super.visitClassDeclaration(classDecl, ctx);
            }
        };
    }
}
```





### 步骤3：测试

```java
package com.yourorg;

import com.yourorg.table.ClassHierarchyReport;
import org.junit.jupiter.api.Test;
import org.openrewrite.test.RecipeSpec;
import org.openrewrite.test.RewriteTest;

import static org.assertj.core.api.Assertions.assertThat;
import static org.openrewrite.java.Assertions.java;

class ClassHierarchyTest implements RewriteTest {

    @Override
    public void defaults(RecipeSpec spec) {
        spec.recipe(new ClassHierarchy());
    }

    @Test
    void basic() {
        rewriteRun(
          spec -> spec.dataTable(ClassHierarchyReport.Row.class, rows -> {
              assertThat(rows).containsExactly(new ClassHierarchyReport.Row("A", ClassHierarchyReport.Relationship.EXTENDS, "java.lang.Object"));
          }),
          //language=java
          java(
              """
              class A {}
              """
          )
        );
    }

    @Test
    void bExtendsA() {
        rewriteRun(
          spec -> spec.dataTable(ClassHierarchyReport.Row.class, rows -> {
              assertThat(rows).containsExactly(
                new ClassHierarchyReport.Row("A", ClassHierarchyReport.Relationship.EXTENDS, "java.lang.Object"),
                new ClassHierarchyReport.Row("B", ClassHierarchyReport.Relationship.EXTENDS, "A"));
          }),
          //language=java
          java(
              """
              class A {}
              """
          ),
          //language=java
          java(
              """
              class B extends A {}
              """
          )
        );
    }

    @Test
    void interfaceRelationship() {
        rewriteRun(
          spec -> spec.dataTable(ClassHierarchyReport.Row.class, rows -> {
              assertThat(rows).containsExactly(
                new ClassHierarchyReport.Row("A", ClassHierarchyReport.Relationship.EXTENDS, "java.lang.Object"),
                new ClassHierarchyReport.Row("A", ClassHierarchyReport.Relationship.IMPLEMENTS, "java.io.Serializable"));
          }),
          // language=java
          java(
              """
              import java.io.Serializable;
              class A implements Serializable {}
              """
          )
        );
    }
}
```



### 步骤4：生成数据表

默认情况下`recipe`不会输出数据表，想要的话需要做两个配置：

- `rewrite-maven-plugin`插件版本要求`5.39.0`以上
- 在`pom.xml`文件中增加`<exportDatatables>true</exportDatatables>`

```xml
<plugin>
    <groupId>org.openrewrite.maven</groupId>
    <artifactId>rewrite-maven-plugin</artifactId>
    <version>6.16.0</version>
    <configuration>
        <exportDatatables>true</exportDatatables>
        <activeRecipes>
            <recipe>com.mycompany.app.ClassHierarchy</recipe>
        </activeRecipes>
    </configuration>
</plugin>
```

然后和平常一样`mvn rewrite:run`，你可以在`target/rewrite/datatables`文件夹中找到生成的数据表。


|Class name|Relationship|Super class name|
| --- | --- | --- |
|org.springframework.samples.petclinic.model.BaseEntity | EXTENDS | java.lang.Object|
|org.springframework.samples.petclinic.model.BaseEntity | IMPLEMENTS | java.io.Serializable|
|org.springframework.samples.petclinic.model.NamedEntity | EXTENDS | org.springframework.samples.petclinic.model.BaseEntity|
|org.springframework.samples.petclinic.model.Person | EXTENDS | org.springframework.samples.petclinic.model.BaseEntity|
|org.springframework.samples.petclinic.owner.Owner |EXTENDS | org.springframework.samples.petclinic.model.Person|





## 4.9 在recipe中创建多个visitor

当我们开始编写越来越复杂的`recipe`时，会发现通常需要一个以上的`visitor`。这是因为重大更改通常需要访问许多类型的无损语义树，以确定是否应该进行更改。

比如我们想对所有没有进行二次赋值的局部变量增加`final`修饰符，首先要确定哪些变量目前没有`final`。然后需要跟踪它们被使用的地方，确保没有进行二次赋值。最后对这些局部变量，才可以正确地设置`final`。

让我们来实现这样的功能，编写一个`FinalizeLocalVariables`。

`Java`中的变量包括：

- Initialized or uninitialized
- Defined or modified in a loop
- Instance variables or class variables
- Named the same thing, but be in different scopes
- Created in a catch block
- Created in a method declaration
- Lambda variables
- Used in combination with a unary operator
- Inside nested blocks
- Declared on the same line

==一个`recipe`的影响面应该尽可能小==，我们规定在以下情况中，`FinalizeLocalVariables`不会进行处理

- Already have the `final` modifier
- Are reassigned
- Are uninitialized
- Are for loop control variables
- Are instance or class variables
- Are in a catch block
- Are declared in static initializers
- Are declared in method parameters
- Are lambdas



### 步骤1：编写测试

首先考虑不受影响的局部变量。

```java
package com.yourorg;

import org.junit.jupiter.api.Test;
import org.openrewrite.test.RecipeSpec;
import org.openrewrite.test.RewriteTest;

import static org.openrewrite.java.Assertions.java;

public class FinalizeLocalVariablesTest implements RewriteTest {
    @Override
    public void defaults(RecipeSpec spec) {
        spec.recipe(new FinalizeLocalVariables());
    }

    @Test
    void doesNotModifyUninitializedVariables() {
        rewriteRun(
            java(
                """
                    class A {
                        void test() {
                            int a;
                            a = 0;
                        }
                    }
                    """
            )
        );
    }

    @Test
    void doesNotModifyLoopControlVariables() {
        rewriteRun(
            java(
                """
                    class A {
                        void test() {
                            for (int i = 0; i < 100; i++) {
                                System.out.println(i);
                            }
                        }
                    }
                    """
            )
        );
    }

    // aka "non-static fields"
    @Test
    void doesNotModifyInstanceVariables() {
        rewriteRun(
            java(
                """
                    class A {
                        int instanceVariableUninitialized;
                        int instanceVariableInitialized = 0;
                    }
                    """
            )
        );
    }

    // aka "static fields"
    @Test
    void doesNotModifyClassVariables() {
        rewriteRun(
            java(
                """
                    class A {
                        static int classVariableInitialized = 0;
                    }
                    """
            )
        );
    }

    @Test
    void doesNotModifyVariablesInCatchBlocks() {
        rewriteRun(
            java(
                """
                    import java.io.IOException;

                    class Test {
                        static {
                            try {
                                throw new IOException();
                            } catch (RuntimeException | IOException e) {
                                System.out.println("oops");
                            }
                        }
                    }
                    """
            )
        );
    }

    @Test
    void doesNotModifyVariablesInStaticInitializers() {
        rewriteRun(
            java(
                """
                    class Test {
                        static {
                            int n = 1;
                            for(int i = 0; i < n; i++) {
                            }
                        }
                    }
                    """
            )
        );
    }

    @Test
    void doesNotModifyVariablesCreatedInMethodParameters() {
        rewriteRun(
            java(
                """
                    class Test {
                        private static int testMath(int x, int y) {
                            y = y + y;
                            return x + y;
                        }
                        
                        public static void main(String[] args) { }
                    }
                    """
            )
        );
    }

    @Test
    void doesNotModifyLambdaVariables() {
        rewriteRun(
            java(
                """
                    import java.util.stream.Stream;

                    class A {
                        public boolean hasFoo(Stream<String> input) {
                            return input.anyMatch(word -> word.equalsIgnoreCase("foo"));
                        }
                    }
                    """
            )
        );
    }
}
```



接下来是需要修改的局部变量。

```java
@Test
void localVariablesAreMadeFinal() {
    rewriteRun(
        java(
            """
                class A {
                    public void test() {
                        int n = 1;
                        for(int i = 0; i < n; i++) { }
                    }
                }
                """,
            """
                class A {
                    public void test() {
                        final int n = 1;
                        for(int i = 0; i < n; i++) { }
                    }
                }
                """
        )
    );
}

@Test
void localVariablesAreMadeFinalWithScopeAwareness() {
    rewriteRun(
        java(
            """
                class Test {
                    public static void testA() {
                        int a = 0;
                        a = 1;
                    }

                    public static void testB() {
                        int a = 0;
                    }
                }
                """,
            """
                class Test {
                    public static void testA() {
                        int a = 0;
                        a = 1;
                    }

                    public static void testB() {
                        final int a = 0;
                    }
                }
                """
        )
    );
}

@Test
void nonModifyingUnaryOperatorAwareness() {
    rewriteRun(
        java(
            """
                class Test {
                    void test() {
                        int i = 1;
                        int j = -i;
                        int k = +j;
                        int l = ~k;
                    }
                }
            """,
            """
                class Test {
                    void test() {
                        final int i = 1;
                        final int j = -i;
                        final int k = +j;
                        final int l = ~k;
                    }
                }
            """
        )
    );
}
```



### 步骤2：编写recipe

有点复杂，需要进一步理解。

```java
package com.mycompany.app;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.openrewrite.Cursor;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Recipe;
import org.openrewrite.Tree;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.TreeVisitingPrinter;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.Space;
import org.openrewrite.marker.Markers;

import java.util.Collections;
import java.util.concurrent.atomic.AtomicBoolean;

public class FinalizeLocalVariables extends Recipe {

    @Override
    public String getDisplayName() {
        return "Finalize local variables";
    }

    @Override
    public String getDescription() {
        return "Adds the `final` modifier keyword to local variables which are not reassigned.";
    }

    @Override
    public JavaIsoVisitor<ExecutionContext> getVisitor() {
        return new JavaIsoVisitor<ExecutionContext>() {
            @Override
            public J.VariableDeclarations visitVariableDeclarations(J.VariableDeclarations varDec, ExecutionContext executionContext) {
                J.VariableDeclarations variableDeclarations = super.visitVariableDeclarations(varDec, executionContext);

                // If the varDec already has a "final" modifier, we don't need to check anything else
                if (variableDeclarations.hasModifier(J.Modifier.Type.Final)) {
                    return variableDeclarations;
                }

                // If any variable is uninitialized, we should make no changes
                if (variableDeclarations.getVariables().stream().anyMatch(namedVariable -> namedVariable.getInitializer() == null)) {
                    return variableDeclarations;
                }

                // If the varDec is in a for loop control, we should make no changes
                if (isDeclaredInForLoopControl(getCursor())) {
                    return variableDeclarations;
                }

                // Fields should not be changed (aka "instance variables" and "class variables")
                if (variableDeclarations.getVariables().stream().anyMatch(namedVariable -> namedVariable.isField(getCursor()) || isField(getCursor()))) {
                    return variableDeclarations;
                }

                if (variableDeclarations.getVariables().stream()
                        .noneMatch(namedVariable ->
                                FindAssignmentReferencesToVariable.find(getCursor()
                                                        .getParentTreeCursor()
                                                        .getValue(),
                                                namedVariable)
                                        .get())) {
                    variableDeclarations = autoFormat(
                            variableDeclarations.withModifiers(
                                    ListUtils.concat(variableDeclarations.getModifiers(), new J.Modifier(Tree.randomId(), Space.EMPTY, Markers.EMPTY, null, J.Modifier.Type.Final, Collections.emptyList()))
                            ), executionContext);
                }

                return variableDeclarations;
            }
        };
    }


    private boolean isDeclaredInForLoopControl(Cursor cursor) {
        return cursor.getParentTreeCursor()
                .getValue() instanceof J.ForLoop.Control;
    }

    private boolean isField(Cursor cursor) {
        return cursor.dropParentUntil(parent -> parent instanceof J.ClassDeclaration || parent instanceof J.MethodDeclaration)
                .getValue() instanceof J.ClassDeclaration;
    }

    @Value
    @EqualsAndHashCode(callSuper = false)
    private static class FindAssignmentReferencesToVariable extends JavaIsoVisitor<AtomicBoolean> {

        J.VariableDeclarations.NamedVariable variable;

        /**
         * @param subtree   The subtree to search.
         * @param variable  A {@link J.VariableDeclarations.NamedVariable} to check for any reassignment calls.
         * @return An {@link AtomicBoolean} that is true if the variable has been reassigned and false otherwise.
         */
        static AtomicBoolean find(J subtree, J.VariableDeclarations.NamedVariable variable) {
            return new FindAssignmentReferencesToVariable(variable)
                    .reduce(subtree, new AtomicBoolean());
        }

        @Override
        public J.Assignment visitAssignment(J.Assignment a, AtomicBoolean hasAssignment) {
            // Return quickly if the variable has been reassigned before
            if (hasAssignment.get()) {
                return a;
            }

            J.Assignment assignment = super.visitAssignment(a, hasAssignment);

            if (assignment.getVariable() instanceof J.Identifier) {
                J.Identifier identifier = (J.Identifier) assignment.getVariable();

                if (identifier.getSimpleName().equals(variable.getSimpleName())) {
                    hasAssignment.set(true);
                }
            }

            return assignment;
        }

        @Override
        public J.AssignmentOperation visitAssignmentOperation(J.AssignmentOperation assignOp, AtomicBoolean hasAssignment) {
            if (hasAssignment.get()) {
                return assignOp;
            }

            J.AssignmentOperation assignmentOperation = super.visitAssignmentOperation(assignOp, hasAssignment);

            if (assignmentOperation.getVariable() instanceof J.Identifier) {
                J.Identifier identifier = (J.Identifier) assignmentOperation.getVariable();

                if (identifier.getSimpleName().equals(variable.getSimpleName())) {
                    hasAssignment.set(true);
                }
            }

            return assignmentOperation;
        }

        @Override
        public J.Unary visitUnary(J.Unary u, AtomicBoolean hasAssignment) {
            if (hasAssignment.get()) {
                return u;
            }

            J.Unary unary = super.visitUnary(u, hasAssignment);

            if (unary.getOperator().isModifying() && unary.getExpression() instanceof J.Identifier) {
                J.Identifier identifier = (J.Identifier) unary.getExpression();

                if (identifier.getSimpleName().equals(variable.getSimpleName())) {
                    hasAssignment.set(true);
                }
            }

            return unary;
        }
    }
}
```





# 5. Java工程的recipe例子



## 5.1 Find Method Usages

[Find method usages | OpenRewrite Docs](https://docs.openrewrite.org/recipes/analysis/search/findmethods)



## 5.2 Add method parameter to a method declaration

[Add method parameter to a method declaration | OpenRewrite Docs](https://docs.openrewrite.org/recipes/java/addmethodparameter)



## 5.3 Add or update annotation attribute

[Add or update annotation attribute | OpenRewrite Docs](https://docs.openrewrite.org/recipes/java/addorupdateannotationattribute)



## 5.4 Change annotation attribute name

[Change annotation attribute name | OpenRewrite Docs](https://docs.openrewrite.org/recipes/java/changeannotationattributename)



## 5.5 Create Java class

[Create Java class | OpenRewrite Docs](https://docs.openrewrite.org/recipes/java/createemptyjavaclass)



## 5.6 Reorder method arguments

[Reorder method arguments | OpenRewrite Docs](https://docs.openrewrite.org/recipes/java/reordermethodarguments)



## 5.7 Search

[Search | OpenRewrite Docs](https://docs.openrewrite.org/recipes/java/search)





# 声明式yaml

在之前的章节中介绍了，声明式`recipe`通过`yaml`文件实现，非常方便。

我们可以在两个位置定义`rewrite.yml`文件：

- 在项目根目录下创建，可以用于本项目重构。
- 在`META-INF/rewrite`文件夹下创建，一般以`jar`包形式提供给其他项目使用

当编写`yml`文件时，记住以下约定：

- 一个文件可以包含任意数量的`recipe`和`style`，它们之间通过`---`分隔
- `recipe`和`style`的名字必须是唯一的



## 格式

编写`rewrite.yml`需要提供的参数如下：

| Key                                                          | Type                                                         | Description                                                  |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| type                                                         | const                                                        | A constant: `specs.openrewrite.org/v1beta/recipe`            |
| name                                                         | string                                                       | A fully qualified, unique name for this recipe               |
| displayName                                                  | string                                                       | A human-readable name for this recipe (does not end with a period) |
| description                                                  | string                                                       | A human-readable description for this recipe (ends with a period) |
| tags                                                         | array of strings                                             | A list of strings that help categorize this recipe           |
| estimatedEffortPerOccurrence                                 | [duration](https://docs.oracle.com/javase/8/docs/api/java/time/Duration.html#parse-java.lang.CharSequence-) | The expected amount of time saved each time this recipe fixes something |
| causesAnotherCycle                                           | boolean                                                      | Whether or not this recipe can cause another cycle (defaults to false) |
| [recipeList](https://docs.openrewrite.org/reference/yaml-format-reference#recipe-list) | array of recipes                                             | The list of recipes which comprise this recipe               |



## 前提条件

前提条件能限制`recipe`对哪些文件进行修改。在`rewrite.yml`使用`preconditions`时，也是以`recipe`的形式。如果存在多个前提条件，则必须满足所有的条件，一个源文件才会被纳入修改范围。如下面例子：

```yml
---
type: specs.openrewrite.org/v1beta/recipe
name: org.openrewrite.PreconditionExample
preconditions:
  - org.openrewrite.text.Find:
      find: 1
recipeList:
  - org.openrewrite.text.ChangeText:
     toText: 2
```

通常被用作前提条件的`recipe`包括：

- `org.openrewrite.FindSourceFiles` - limits the recipe to only run on files whose path matches a glob pattern
- `org.openrewrite.text.Find` - limits the recipe to only run on files that contain a given string
- `org.openrewrite.java.search.FindTypes` - limits the recipe to run only on source code which contain a given type
- `org.openrewrite.java.search.HasJavaVersion` - limits the recipe to run only on Java source code with the specified source or target compatibility versions. Allowing a recipe to be targeted only at Java 8, 11, 17, etc., code.
- `org.openrewrite.java.search.IsLikelyTest` - limits the recipe to run only on source code which is likely to be test code.
- `org.openrewrite.java.search.IsLikelyNotTest` - limits the recipe to run only on source code which is likely to be production code.

如果我们想定义`OR`的条件关系，就需要创建一个额外的`recipe`，如下所示：

```yml
type: specs.openrewrite.org/v1beta/recipe
name: org.sample.DoSomething
displayName: Do Something
preconditions:
  - org.sample.FindAnyJson
recipeList:
  - org.openrewrite.json.ChangeKey:
      oldKeyPath: $.foo
      newKey: bar
---
type: specs.openrewrite.org/v1beta/recipe
name: org.sample.FindAnyJson
recipeList:
  - org.openrewrite.FindSourceFiles:
      filePattern: "**/my.json"
  - org.openrewrite.FindSourceFiles:
      filePattern: "**/your.json"
  - org.openrewrite.FindSourceFiles:
      filePattern: "**/our.json"
```





# MethodMatcher

`org.openrewrite.java.MethodMatcher`是大多数`recipe`使用方法模式（`Method Pattern`）的方式。

`Method Pattern`提供了一种准确、快速地识别一个或多个方法定义或调用的方法。传统的基于文本的搜索可能会产生数千个不相关的匹配，与之不同的是，方法模式是类型感知的，因此只会找到相关的结果。

一个方法模式必须包括：类名、方法名、参数类型

```java
org.foo.Bar baz(String, int)
```

方法模式还接受通配符：

- `*` - Matches any one thing. Applicable to receiver type, method name, and arguments.
- `..` - Matches zero or more. Applicable to receiver type and arguments.



## 方法模式

下面展示了一些方法模式例子：

| Method Pattern                               | Matches                                                      |
| -------------------------------------------- | ------------------------------------------------------------ |
| `java.lang.String substring(int)`            | Exactly the [single argument overload](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html#substring(int)) of `String.substring(int beginIndex)`. |
| `java.lang.String substring(int, int)`       | Exactly the [two argument overload](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html#substring(int,int)) of `String.substring(int beginIndex, int endIndex)`. |
| `java.lang.String substring(..)`             | Any overload of `String.substring()` with any number of arguments. |
| `java.lang.String *(int)`                    | Any method on `String` that accepts a single argument of type `int`. |
| `java.lang.String valueOf(*)`                | Any overload of `String.valueOf()` with exactly one argument. |
| `java.lang.String format(String, ..)`        | Exactly the [String.format(String format, Object... args)](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html#format(java.lang.String,java.lang.Object...)) method with varargs. |
| `java.lang.String format(String, Object[])`  | Exactly the [String.format(String format, Object... args)](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html#format(java.lang.String,java.lang.Object...)) method with varargs. |
| `java.lang.String format(String, Object...)` | Exactly the [String.format(String format, Object... args)](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html#format(java.lang.String,java.lang.Object...)) method with varargs. |
| `com.yourorg.Foo bar(int, String, ..)`       | Any method on `Foo` named `bar` accepting an `int`, a `String`, and zero or more other arguments of any type. |
| `*..String *(..)`                            | Any method accepting any arguments on classes named "String" in any package. |
| `*..* *(..)`                                 | Any method accepting any arguments on any class.             |
| `*..* *(String...)`                          | Any method accepting any String varargs on any class.        |
| `*..* *(*, *, *, ..)`                        | Any method accepting at least three arguments on any class.  |
| `*..* foo(..)`                               | Any method named `foo` which accepts any number of arguments. This is the equivalent of doing a generic text search for methods named `foo`. |
| `org..* foo(..)`                             | Any method named `foo` in a package that starts with `org`. This could be `org.meow` or it could be `org.springframework` or so on. |
| `org.openrewrite.java.* foo(..)`             | Any method named `foo` in a package that starts with `org.openrewrite.java.`. Note that the `.*` after `java` means that the method *must* be in this package rather than some subsequent subpackages. |
| `org.Foo bar(java.util.List)`                | Exactly the `bar` method in the `org.Foo` class that takes in a single `java.util.List` as an argument. |
| `org.Foo bar(java.*.*, *)`                   | Exactly the `bar` method in the `org.Foo` class that takes two arguments of which the first argument type is nested exactly 2 levels deep in the `java` package. |
| `org.Foo <constructor>(..)`                  | Matches any constructors in the `org.Foo` class that takes in any number of arguments. |
| `org.Foo <init>(..)`                         | Matches the same thing as the previous line. Demonstrates that `init` can be used as an alias of `constructor`. |
| `org.Foo bar()`                              | Matches exactly the `bar` method in the `org.Foo` class that has **no** arguments |
| `org.Foo#bar()`                              | Matches the same thing as the previous line. Demonstrates that `#` can be used to replace a space – which may be useful for certain types of input such as a CLI. |

## 例子

下面是一个查找指定方法，并修改方法名的`visitor`，注意别忘了方法调用也需要修改。

```java
// Adapted from org.openrewrite.java.ChangeMethodName for the sake of an example
// This lacks the full functionality of the complete Recipe
class ChangeMethodNameVisitor extends JavaIsoVisitor<ExecutionContext> {
    @Option(displayName = "New method name",
            description = "The method name that will replace the existing name.",
            example = "someNewName")
    String newMethodName;

    // More options ...

    private final MethodMatcher methodMatcher;

    private ChangeMethodNameVisitor(String pointcutExpression) {
        this.methodMatcher = new MethodMatcher(pointcutExpression);
    }

    @Override
    public J.MethodDeclaration visitMethodDeclaration(J.MethodDeclaration method, ExecutionContext ctx) {
        J.MethodDeclaration md = super.visitMethodDeclaration(method, ctx);
        J.ClassDeclaration classDecl = getCursor().firstEnclosingOrThrow(J.ClassDeclaration.class);

        // The enclosing class of a J.MethodDeclaration must be known for a MethodMatcher to match it
        if (methodMatcher.matches(method, classDecl)) {
            JavaType.Method type = md.getMethodType();

            // Note that both the name and the type information on the declaration are updated together
            // Maintaining this consistency is important for maintaining the correct operation of other recipes
            if (type != null) {
                type = type.withName(newMethodName);
            }

            md = md.withName(md.getName().withSimpleName(newMethodName).withType(type))
                                .withMethodType(type);
        }

        return md;
    }

    @Override
    public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
        J.MethodInvocation mi = super.visitMethodInvocation(method, ctx);

        // Type information stored in the J.MethodInvocation indicates the class so no second argument is necessary
        if (methodMatcher.matches(method)) {
            JavaType.Method type = mi.getMethodType();

            // Note that both the name and the type information on the invocation are updated together
            // Maintaining this consistency is important for maintaining the correct operation of other recipes
            if (type != null) {
                type = type.withName(newMethodName);
            }

           mi = mi.withName(mi.getName().withSimpleName(newMethodName).withType(type))
                                .withMethodType(type);
        }

        return mi;
    }

    // Other implementation follows
}
```



# Concepts & explanations

## 无损语义树

https://docs.openrewrite.org/concepts-and-explanations/lossless-semantic-trees

https://docs.openrewrite.org/concepts-and-explanations/lst-examples





使用`TreeVisitingPrinter`输出语义树。这可以帮助我们找到需要处理的LST。

![无损语义树](https://docs.openrewrite.org/assets/images/TreeVisitingPrinterExample-166ff7a563a6a8a223b72c96058c13ed.png)



# visitor

https://docs.openrewrite.org/concepts-and-explanations/visitors



# recipe

https://docs.openrewrite.org/concepts-and-explanations/recipes



# rewrite-maven-plugin 原理

使用`rewrite-maven-plugin`是运行`recipe`最快速的方式。

该插件提供如下的`goal`：

- `mvn rewrite:run`：运行配置的`recipe`并在本地应用更改。

- `mvn rewrite:runNoFork`
- `mvn rewrite:dryRun`：将哪些`visitor`将对哪些文件进行更改打印到构建日志中。这不会改变源文件，可用于预览`recipe`所做的更改。生成的文件位于目录`target/site/rewrite/rewrite.patch`
- `mvn rewrite:dryRunNoFork`
- `mvn rewrite:discover`：生成在类路径上找到的可用`recipe`的报告



如果`dryRun`检测到要做的更改并且`failOnDryRunResults`设置为`true`，则可以在持续集成环境（`Continuous Integration`）中通过失败构建来使用`dryRun`作为`gate`：

```xml
<configuration>
  <failOnDryRunResults>true</failOnDryRunResults>
</configuration>
```





#  rewrite 原理

https://github.com/openrewrite/rewrite

[Building and developing OpenRewrite | OpenRewrite Docs](https://docs.openrewrite.org/reference/building-openrewrite-from-source)





# recipe大全

[Lists | OpenRewrite Docs](https://docs.openrewrite.org/lists)